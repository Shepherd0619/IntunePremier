using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AutopilotHelper.Utilities
{
    public class CustomDiagUtil : MDMFileUtil
    {
        public CustomDiagUtil(string filePath) : base(filePath)
        {
        }

        public override int CheckWhetherZipMeetPrerequisite()
        {
            using (var zip = ZipFile.OpenRead(FilePath))
            {
                var files = zip.Entries;

                for (int i = 0; i < files.Count; i++)
                {
                    if(files[i].Comment != "INTUNE_PREMIER")
                    {
                        return -1;
                    }
                }

                return 0;
            }
        }

        public static bool IsThisACustomDiag(string filePath)
        {
            try
            {
                using (var zip = ZipFile.OpenRead(filePath))
                {
                    var files = zip.Entries;

                    for (int i = 0; i < files.Count; i++)
                    {
                        if (files[i].Comment != "INTUNE_PREMIER")
                        {
                            return false;
                        }
                    }

                    return true;
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error checking if file is a custom diag: {ex.Message}");
                return false;
            }
        }

        public override async Task Extract()
        {
            if(CheckWhetherZipMeetPrerequisite() != 0)
            {
                throw new Exception($"Not a valid zip generated by AutopilotHelper. ");
            }

            var fileStream = File.OpenRead(FilePath);
            using (var archive = new ZipArchive(fileStream, ZipArchiveMode.Read, true))
            {
                foreach (var entry in archive.Entries)
                {
                    // Get the full path of the entry
                    var fullPath = Path.Combine(TmpWorkspacePath, entry.FullName);

                    // Create the directory if it doesn't exist
                    var dirPath = Path.GetDirectoryName(fullPath);
                    if (!string.IsNullOrEmpty(dirPath) && !Directory.Exists(dirPath))
                    {
                        Directory.CreateDirectory(dirPath);
                    }

                    // Extract the entry to the target path
                    await Task.Run(() => entry.ExtractToFile(fullPath));

                    if (Path.GetExtension(entry.FullName).Equals(".zip", StringComparison.OrdinalIgnoreCase) && Path.GetFileNameWithoutExtension(entry.FullName) == "MDMDiagReport")
                    {
                        await ExtractZip(File.OpenRead(fullPath));
                    }
                }
            }

            fileStream.Close();
            fileStream.Dispose();
        }

        private async Task ExtractZip(FileStream fileStream)
        {
            using (var archive = new ZipArchive(fileStream, ZipArchiveMode.Read, true))
            {
                foreach (var entry in archive.Entries)
                {
                    // Get the full path of the entry
                    var fullPath = Path.Combine(TmpWorkspacePath, entry.FullName);

                    // Create the directory if it doesn't exist
                    var dirPath = Path.GetDirectoryName(fullPath);
                    if (!string.IsNullOrEmpty(dirPath) && !Directory.Exists(dirPath))
                    {
                        Directory.CreateDirectory(dirPath);
                    }

                    // Extract the entry to the target path
                    await Task.Run(() => entry.ExtractToFile(fullPath));
                }
            }

            fileStream.Close();
            fileStream.Dispose();
        }
    }
}
