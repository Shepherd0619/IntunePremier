using System.Diagnostics;
using System.IO.Compression;

namespace AutopilotHelper.Utilities
{
    public class MDMFileUtil
    {
        /// <summary>
        /// This path represents the zip file extract destination.
        /// </summary>
        public string TmpWorkspacePath = Path.Combine(Path.GetTempPath(), $"IntunePremier/TmpWorkspace/{Guid.NewGuid().ToString()}");
        public string FilePath => filePath;
        private string filePath;

        public MDMFileUtil(string filePath)
        {
            if (!Directory.Exists(TmpWorkspacePath))
            {
                Directory.CreateDirectory(TmpWorkspacePath);
            }

            this.filePath = filePath;
        }

        /// <summary>
        /// Will verify whether this is the zip generated by the MDM.
        /// If not and the diag is generated by Intune Admin Center, we will extract the mdm diag cab file inside and try again.
        /// </summary>
        /// <returns>-1 means invalid, 0 means valid, 1 means need to extract cab inside</returns>
        public virtual int CheckWhetherZipMeetPrerequisite()
        {
            using (var zip = ZipFile.OpenRead(FilePath))
            {
                var requiredFiles = new HashSet<string>
                {
                    "MdmDiagLogMetadata.json",
                    "MdmDiagReport_RegistryDump.reg"
                };

                // Check for .evtx files
                var evtxFilesFound = zip.Entries.Any(entry => entry.FullName.EndsWith(".evtx", StringComparison.OrdinalIgnoreCase));

                var firstScanResult = requiredFiles.All(file => zip.Entries.Any(entry => entry.Name.Contains(file))) &&
                       evtxFilesFound;

                if (!firstScanResult)
                {
                    var cab = zip.Entries.FirstOrDefault(entry => entry.Name.EndsWith(".cab", StringComparison.OrdinalIgnoreCase) && 
                    entry.Name.StartsWith("mdmlogs-", StringComparison.OrdinalIgnoreCase));

                    if (cab != null)
                    {
                        var outputPath = Path.Combine(TmpWorkspacePath, cab.Name);
                        cab.ExtractToFile(outputPath, true);
                        filePath = outputPath;
                        return 1;
                    }
                    else
                    {
                        return -1;
                    }
                }
                else
                {
                    return 0;
                }
            }
        }

        public virtual async Task Extract()
        {
            var fileNameSplit = Path.GetFileName(FilePath).Split('.');
            if (fileNameSplit[fileNameSplit.Length - 1].Equals("cab", StringComparison.OrdinalIgnoreCase))
            {

                var process = new Process();
                process.StartInfo = new();
                process.StartInfo.FileName = "expand.exe";
                process.StartInfo.Arguments = $"\"{FilePath}\" -F:* \"{Path.Combine(TmpWorkspacePath)}\"";
                process.Start();
                process.WaitForExit();

                if (process.ExitCode != 0)
                {
                    throw new Exception($"expand exit code is {process.ExitCode}");
                }
            }
            else
            {
                switch (CheckWhetherZipMeetPrerequisite())
                {
                    case -1:
                        throw new Exception($"Not a valid zip generated by MDM. ");

                    case 1:
                        await Extract();
                        return;
                }

                var fileStream = File.OpenRead(FilePath);
                using (var archive = new ZipArchive(fileStream, ZipArchiveMode.Read, true))
                {
                    foreach (var entry in archive.Entries)
                    {
                        // Get the full path of the entry
                        var fullPath = Path.Combine(TmpWorkspacePath, entry.FullName);

                        // Create the directory if it doesn't exist
                        var dirPath = Path.GetDirectoryName(fullPath);
                        if (!string.IsNullOrEmpty(dirPath) && !Directory.Exists(dirPath))
                        {
                            Directory.CreateDirectory(dirPath);
                        }

                        // Extract the entry to the target path
                        await Task.Run(() => entry.ExtractToFile(fullPath));
                    }
                }

                fileStream.Close();
                fileStream.Dispose();
            }
        }
    }
}
